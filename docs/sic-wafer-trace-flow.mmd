flowchart TB

%% SiC Wafer Trace: fab-to-slice and epi-to-slice genealogy builder
%% Source script: refb_ingest/on_SiCwaferTrace.pl

classDef db fill:#eef,stroke:#468,stroke-width:1px
classDef file fill:#efe,stroke:#484,stroke-width:1px
classDef io fill:#ffd,stroke:#aa6,stroke-width:1px
classDef proc fill:#f6f6f6,stroke:#666,stroke-width:1px
classDef pub fill:#e8f7ff,stroke:#07c,stroke-width:1px

start([Start])

subgraph Inputs
  direction TB
  opt["CLI options<br/>--out dir, --ecoaschema, --start, --end<br/>--meepifile, --usearchive, --archivedir<br/>--deletesfile, --slicelist, --lotlist"]
  env["Env vars<br/>REFDB_TNS, ECOA_TNS<br/>REFDB_USER, REFDB_PASS<br/>ECOA_USER, ECOA_PASS<br/>YMS_PASSWORD"]
  files["Aux files<br/>MEEPIFILE CSV (Maine epi)<br/>DELETESFILE CSV (attr deletes)"]
end
class opt,env,files io

subgraph Connections
  direction TB
  biwmes[(BIWMES Oracle BIWPRD:YMS)]:::db
  refdb[(REFDB Oracle)]:::db
  ecofa[(eCofA Oracle ECOA_TNS<br/>schema: ECOASCHEMA)]:::db
  torrent[(TORRENT Oracle CZ4TRQA)]:::db
end

start --> opt --> env --> files --> init
init["Parse options; validate; ensure out/tmp; load CSVs"]:::proc
init --> biwmes
init --> refdb
init --> ecofa
init --> torrent

subgraph FabTrace[Fab trace: getEpiOrFabTraceSQL 'fab']
  direction TB
  q1["BIWMES query attrs/info<br/>Map slice↔wafer from CRLT<br/>Window: start..end or slicelist/lotlist<br/>Ignore COMETS purge deletes"]:::proc
  adj1["Apply Maine overrides<br/>If slice in MEEPIFILE → UWB epi<br/>slot/lot/product/date from CSV"]:::proc
  d1{UWB epi and deleted attr?}:::proc
  e1["eCofA lookup by GWID or scribe<br/>Get GWID, PUCK_ID, raw and epi meta"]:::proc
  cz1{No eCofA epi? Query TORRENT CZ2}:::proc
  r1["Read REFDB.on_slice by slice or GWID<br/>May remap slice if matched by GWID"]:::proc
  chg["If CHANGED_WAFERS includes current<br/>ON_SLICE fab wafer then allow replace"]:::proc
  upd{Update ON_SLICE needed?<br/>Set fab_wafer_id, fab_source_lot, GWID,<br/>slice_order, lottype if missing}:::proc
  outFab["Build outputs (REFDB→eCofA→NA)<br/>- PUCK2FAB by puck<br/>- FAB2PUCK by source lot<br/>- EPI2PUCK from fab trace<br/>Map CZ2 raw supplier to GTAT"]:::proc
end

biwmes --> q1 --> adj1 --> d1
 d1 --|No|--> e1 --> cz1
 d1 --|Yes|--> outFab
 cz1 --|No|--> r1 --> chg --> upd --> outFab
 cz1 --|Yes|--> r1 --> chg --> upd --> outFab

subgraph EpiTrace[Epi trace: three passes]
  direction TB
  i1["Iter1 BIWMES epi<br/>getEpiOrFabTraceSQL 'epi'<br/>Facilities FBEPI, FM4045, BBLS<br/>Bucheon vs internal routing"]:::proc
  i2["Iter2 TORRENT CZ2 epi<br/>getCZEpiSQL by time or slicelist"]:::proc
  i3["Iter3 eCofA epi by date<br/>get_eCofA_sliceInfoByDate<br/>Exclude CZ2 epi"]:::proc
  adj2["Apply Maine overrides and skip<br/>UWB if deleted attr"]:::proc
  e2["eCofA lookup per slice for GWID,<br/>PUCK_ID, raw and epi meta"]:::proc
  r2["Read REFDB.on_slice; remap GWID→slice if needed"]:::proc
  outEpi["Build EPI2PUCK by source lot<br/>Dedup per source lot and slice<br/>Prefer eCofA when BK non-UWB and available"]:::proc
end

biwmes --> i1 --> adj2 --> e2 --> r2 --> outEpi
torrent --> i2 --> adj2
ecofa --> i3 --> adj2

subgraph Aggregation[Group and write]
  direction TB
  g1["Group PUCK2FAB by PUCK_ID into byFabPuck"]:::proc
  g2["Group FAB2PUCK by SOURCE_LOT into byFabSourceLot"]:::proc
  g3["Group EPI2PUCK by SOURCE_LOT into byEpiSourceLot"]:::proc
  writeTmp["Write CSVs into out/tmp<br/>PUCK2FAB.*.p2f.csv<br/>FAB2PUCK.*.f2p.csv<br/>EPI2PUCK.*.e2p.csv"]:::file
  publish["Copy to ARCHIVEDIR if set<br/>Move tmp files to OUT dir"]:::pub
end

outFab --> g1 --> writeTmp --> publish --> done((Done))
outFab --> g2
outEpi --> g3 --> writeTmp

note1["Rules and details<br/>- Time window: start 00:00, end 23:59:59<br/>- Changed wafers: replace fab wafer when listed in CHANGED_WAFERS<br/>- Guess GWID: strip '-' or truncate as needed<br/>- RAW_SUPPLIERID 'CZ2' becomes 'GTAT'<br/>- CZ2 epi: prefer TORRENT; exclude from eCofA-by-date<br/>- Write 'NA' for missing values<br/>- Output has 21 fields per record"]:::io
Aggregation --> note1
